# Feature Specification: Kaiten CLI

**Feature Branch**: `002-kaiten-cli`
**Created**: 2026-02-16
**Status**: Draft
**Input**: User description: "Executable-таргет — тонкая обёртка над SDK без логики, пробрасывает команды в SDK"

## User Scenarios & Testing *(mandatory)*

### User Story 1 - CLI-доступ к Kaiten (Priority: P1)

DevOps-инженер или разработчик использует CLI для доступа к
данным Kaiten без написания кода. CLI является тонкой обёрткой
над SDK — парсит CLI-аргументы и конфиг-файл, собирает из них
единый набор параметров и передаёт в SDK. Никакой бизнес-логики.

**Why this priority**: Единственная задача этой фичи — дать
CLI-доступ к SDK.

**Independent Test**: Запустить бинарник с `--url`, `--token`
и подкомандой (например `list-spaces`). Структурированный вывод
в stdout подтверждает работоспособность.

**Acceptance Scenarios**:

1. **Given** валидные `--url` и `--token` флаги, **When**
   пользователь запускает подкоманду (например `list-spaces`),
   **Then** CLI выводит структурированные данные в stdout.
2. **Given** существует валидный конфиг-файл
   `~/.config/kaiten-mcp/config.json`, **When** пользователь
   запускает подкоманду без флагов, **Then** CLI читает
   параметры из конфиг-файла.
3. **Given** присутствуют и флаги и конфиг-файл с разными
   значениями, **When** пользователь указывает `--url` или
   `--token`, **Then** флаги имеют приоритет над конфиг-файлом.
4. **Given** ни флаги, ни конфиг-файл не предоставляют
   обязательный параметр, **When** пользователь запускает
   подкоманду, **Then** CLI выходит с понятным сообщением об
   ошибке, указывающим какой параметр отсутствует и где его
   можно задать (флаг или конфиг-файл).
5. **Given** SDK возвращает ошибку, **When** пользователь
   запускает подкоманду, **Then** CLI выводит человекочитаемое
   сообщение об ошибке в stderr и завершается с ненулевым
   кодом возврата.

---

### Edge Cases

- Что если CLI запущен без подкоманды? CLI MUST вывести справку
  и завершиться с ненулевым кодом.
- Что если конфиг-файл существует, но содержит невалидный JSON?
  CLI MUST вывести ошибку с описанием проблемы конфигурации.
- Что если конфиг-файл не существует и флаги не переданы?
  CLI MUST вывести ошибку с инструкцией: передать флаги или
  создать `~/.config/kaiten-mcp/config.json`.

## Requirements *(mandatory)*

### Functional Requirements

- **FR-001**: CLI MUST быть тонкой обёрткой над SDK без
  собственной бизнес-логики. CLI парсит аргументы и
  конфиг-файл, собирает единый Input и передаёт в SDK.
- **FR-002**: CLI MUST предоставлять подкоманду для каждого
  convenience-метода SDK с соответствующими аргументами.
- **FR-003**: CLI MUST резолвить параметры подключения в
  порядке приоритета: флаги командной строки > конфиг-файл.
  Переменные окружения НЕ используются.
- **FR-004**: CLI MUST выводить структурированные данные в
  stdout и ошибки в stderr.
- **FR-005**: CLI MUST завершаться с кодом 0 при успехе и
  ненулевым при ошибке.
- **FR-006**: CLI MUST компилироваться и работать на macOS (ARM)
  и Linux (x86-64 и ARM).
- **FR-007**: Конфигурация хранится в двух файлах в общей
  директории `~/.config/kaiten-mcp/` (все платформы):
  - **`config.json`** — подключение (url, token):
    ```json
    {
      "url": "https://company.kaiten.ru/api/latest",
      "token": "your-api-token"
    }
    ```
  - **`preferences.json`** — пользовательские настройки
    (избранные доски, пространства). Управляется KaitenMCP.
    CLI не читает и не пишет этот файл.

  CLI читает только `config.json`.
- **FR-008**: CLI MUST использовать `swift-configuration`
  (`ConfigReader` + `FileProvider<JSONSnapshot>`) для чтения
  конфиг-файла. `swift-configuration` — зависимость только
  CLI-таргета, не SDK.

## Success Criteria *(mandatory)*

### Measurable Outcomes

- **SC-001**: CLI можно использовать в скриптах автоматизации —
  каждая подкоманда принимает все входные данные через флаги
  или конфиг-файл и выдаёт машиночитаемый вывод.
- **SC-002**: CLI не содержит дублирования логики SDK — каждая
  подкоманда только вызывает соответствующий метод SDK.
- **SC-003**: CLI компилируется и работает на macOS (ARM) и
  Linux (x86-64 и ARM).
